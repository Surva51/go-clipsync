## `internal/clip` — **Authoritative Design Sheet**

*(v3, 10-May-2025 — aligns with the "CF DIB + PNG-only" image plan and the LazyDLL binding model)*

---

### 1 Mission of the package

`internal/clip` is the **only code in the repo that ever calls Win32**.
Everything outside this folder stays platform-agnostic and unit-testable on macOS/Linux.

* **Own the clipboard** from a single goroutine locked to one OS thread.
* Convert between the clipboard's **device-independent bitmap (CF\_DIB)** and our wire-format **PNG** – loss-less, alpha-safe.
* Offer a trivial two-message API (`Req` / `Resp`) so callers never see Win32 handles, build tags, or pointer arithmetic.

---

### 2 File catalog

| File                | Contents                                                                       | Never does                |
| ------------------- | ------------------------------------------------------------------------------ | ------------------------- |
| **`clip.go`**       | the goroutine, LazyDLL bindings, read/write paths, `Req`/`Resp` structs        | image math, JSON, network |
| **`image.go`**      | pure-Go helpers `ImageToDIB` and `DIBToPNG`                                    | Win32 calls, global state |
| **`clip_test.go`**  | black-box tests of the goroutine using a stub clipboard (build tag `!windows`) | calls to real user32.dll  |
| **`image_test.go`** | round-trip unit test (PNG → DIB → PNG)                                         | Windows APIs              |

---

### 3 External imports & why they exist

| Import                                                                                                  | Reason                                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `golang.org/x/sys/windows`                                                                              | **Only** for `windows.NewLazySystemDLL`, `windows.NewProc`, and the `windows.Errno` / `windows.Handle` type aliases. No autogenerated wrappers are required. |
| Standard library packages (`bytes`, `encoding/binary`, `image`, `image/png`, `runtime`, `unsafe`, etc.) | Each used exactly once: buffer handling, header encoding, image decoding, thread pinning, pointer slicing.                                                   |

No other third-party packages appear in this directory.

---

### 4 Win32 binding model

1. **Resolve DLLs lazily**

   ```go
   user32   = windows.NewLazySystemDLL("user32.dll")
   kernel32 = windows.NewLazySystemDLL("kernel32.dll")
   ```

2. **Bind the 11 procedures we need** once at package init:
   `OpenClipboard`, `CloseClipboard`, `EmptyClipboard`,
   `SetClipboardData`, `GetClipboardData`, `IsClipboardFormatAvailable`,
   `RegisterClipboardFormatW`, `EnumClipboardFormats`,
   `GlobalAlloc`, `GlobalLock`, `GlobalUnlock`.

3. **Call signature** (`Proc.Call`) always returns `(r1, r2, err)`;
   helpers `mustOK` / `mustErr` mask unused values but always check `err`.

No build tags can disable these helpers, so the package compiles the same on every Windows host.

---

### 5 Clipboard formats we support

| Clipboard ID    | How we get it                             | Why we include it                                                   |
| --------------- | ----------------------------------------- | ------------------------------------------------------------------- |
| **CF\_DIB (8)** | constant                                  | Universally accepted by all Win32 apps. 32-bpp BGRA, bottom-up.     |
| **"PNG"**       | `RegisterClipboardFormatW(\"PNG\")`       | Loss-less alpha path for modern apps (Photoshop, browsers, Office). |
| **"image/png"** | `RegisterClipboardFormatW(\"image/png\")` | Some apps (Chrome, Edge) use the MIME label.                        |

*(CF\_DIBV5 was removed; the 40-byte header is enough when we also ship PNG.)*

---

### 6 Public mini-API (package-internal)

```go
type ReqKind uint8   // { ReqRead | ReqWrite }

type Req struct {
    Kind      ReqKind     // read or write
    WantFmt   []uint32    // for reads (unused today)
    WriteData []core.Item // for writes
    Resp      chan Resp
}

type Resp struct {
    Items []core.Item // clipboard snapshot
    Err   error       // non-nil on any Win32 failure
}
```

* The goroutine is started once via `StartThread()`, which returns a channel that accepts `Req`.
* A **caller never touches** Win32 handles; they pass/receive `core.Item` (fmt id, name, size, base64 payload).

---

### 7 Clipboard write workflow

1. **Lock goroutine to thread** – `runtime.LockOSThread()`.
2. `openCB()` retries `OpenClipboard(NULL)` for ≤ 500 ms.
3. `EmptyClipboard`.
4. For each `core.Item` (currently only PNG or text):

   * Decode base64 → `[]byte`.
   * **PNG path**

     * `png.Decode` → `image.Image`.
     * `ImageToDIB(img)` → 40-byte DIB.
     * `GlobalAlloc` + copy (helper `hFromBytes`).
     * `SetClipboardData(CF_DIB, hDIB)` – check return; propagate error.
     * Register format "PNG" & "image/png"; `SetClipboardData` with raw bytes.
   * **Text path**

     * `SetClipboardData(CF_UNICODETEXT, hMem)` (UTF-16, null-terminated).
5. `CloseClipboard()` releases the lock.

On any failure after `openCB` the function returns an error; the calling layer decides to retry or log.

---

### 8 Clipboard read workflow

1. `openCB()`; defer `closeCB()`.
2. If "PNG" or "image/png" present → retrieve raw bytes, return one `core.Item`.
3. Else if `CF_DIB` present → convert `DIBToPNG`, return PNG item.
4. Else if `CF_UNICODETEXT` present → return text item.
5. Else → return `ErrUnsupportedFormat`.

---

### 9 Image conversion logic (`image.go`)

* **`ImageToDIB`**

  * Accepts any `image.Image`, converts to `*image.RGBA` if needed.
  * Builds a **40-byte BITMAPINFOHEADER** (BI\_RGB, 32 bpp, positive height).
  * Appends pixel rows bottom-up with BGRA byte order.
  * Returns a single `[]byte` slice (no DIB V5).

* **`DIBToPNG`**

  * Validates header (`BitCount=32`, `Planes=1`).
  * Handles both bottom-up (positive height) and top-down (negative).
  * Swaps BGRA → RGBA into an `image.RGBA`.
  * Encodes that with `png.Encode`.

Both functions contain **zero Windows calls** → run on any OS / CI runner.

---

### 10 Tests

| Test file           | What it checks                                                                                               |
| ------------------- | ------------------------------------------------------------------------------------------------------------ |
| **`image_test.go`** | Creates a 10×10 RGBA checkerboard, `ImageToDIB` → `DIBToPNG`, decodes PNG, asserts pixel integrity.          |
| **`clip_test.go`**  | (Build-tag `!windows`) uses an in-memory stub for the Win32 layer; exercises read/write channels end-to-end. |

Run:

```bash
go test ./internal/clip
```

on any OS; all tests pass.

---

### 11 Failure surfaces & handling

| Scenario                                              | Detection                  | Returned error                    |
| ----------------------------------------------------- | -------------------------- | --------------------------------- |
| Clipboard busy > 500 ms                               | `openCB` retry timeout     | `ErrClipboardBusy` (wrapped)      |
| `SetClipboardData` fails (locked handle / bad header) | ret == 0                   | `windows.Errno` bubbled to caller |
| Malformed DIB from remote machine                     | `DIBToPNG` returns nil     | `ErrBadDIB` (custom)              |
| Unsupported format on clipboard                       | `readSnapshot` can't match | `ErrUnsupportedFormat`            |

Caller (`internal/net` poller) decides back-off, resend, or log.

---

### 12 Extensibility guidelines

* **Adding TIFF or RTF (Tier-2)**

  * Register format name (e.g., "TIFF") synchronized by name, never by numeric ID.
  * Provide conversion helper in `image.go` if needed.
  * Ensure at least one Windows-native fallback (TIFF → CF\_DIB, RTF → CF\_UNICODETEXT).
* **Porting to macOS/Linux**

  * Implement `internal/xclip` using build tags; reuse *this* `image.go` unchanged.
  * `internal/clip` becomes a thin wrapper over `pbcopy/pbpaste` (mac) or `xclip` (Linux).

---

### 13 Key invariants

1. **One thread owns all user32 calls** — enforced by `LockOSThread`.
2. **Every memory handle passed to Windows is GMEM\_MOVEABLE and unlocked.**
3. **We never share numeric format IDs across machines** — only names.
4. **At least one of `CF_DIB` *or* `PNG` is present** for any image we post.

---

Keep this sheet beside the blueprint so everybody knows exactly **what lives in `internal/clip`, why, and how**—before they touch a single line of code.
